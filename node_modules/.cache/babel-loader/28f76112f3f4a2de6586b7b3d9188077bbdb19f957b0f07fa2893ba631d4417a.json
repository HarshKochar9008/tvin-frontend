{"ast":null,"code":"import { toArray } from './util';\nimport { fetchAsDataURL } from './dataurl';\nimport { shouldEmbed, embedResources } from './embed-resources';\nconst cssFetchCache = {};\nasync function fetchCSS(url) {\n  let cache = cssFetchCache[url];\n  if (cache != null) {\n    return cache;\n  }\n  const res = await fetch(url);\n  const cssText = await res.text();\n  cache = {\n    url,\n    cssText\n  };\n  cssFetchCache[url] = cache;\n  return cache;\n}\nasync function embedFonts(data, options) {\n  let cssText = data.cssText;\n  const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n  const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n  const loadFonts = fontLocs.map(async loc => {\n    let url = loc.replace(regexUrl, '$1');\n    if (!url.startsWith('https://')) {\n      url = new URL(url, data.url).href;\n    }\n    return fetchAsDataURL(url, options.fetchRequestInit, _ref => {\n      let {\n        result\n      } = _ref;\n      cssText = cssText.replace(loc, `url(${result})`);\n      return [loc, result];\n    });\n  });\n  return Promise.all(loadFonts).then(() => cssText);\n}\nfunction parseCSS(source) {\n  if (source == null) {\n    return [];\n  }\n  const result = [];\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n  // strip out comments\n  let cssText = source.replace(commentsRegex, '');\n  // eslint-disable-next-line prefer-regex-literals\n  const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matches = keyframesRegex.exec(cssText);\n    if (matches === null) {\n      break;\n    }\n    result.push(matches[0]);\n  }\n  cssText = cssText.replace(keyframesRegex, '');\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n  // to match css & media queries together\n  const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' + '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n  // unified regex\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let matches = importRegex.exec(cssText);\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText);\n      if (matches === null) {\n        break;\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex;\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex;\n    }\n    result.push(matches[0]);\n  }\n  return result;\n}\nasync function getCSSRules(styleSheets, options) {\n  const ret = [];\n  const deferreds = [];\n  // First loop inlines imports\n  styleSheets.forEach(sheet => {\n    if ('cssRules' in sheet) {\n      try {\n        toArray(sheet.cssRules || []).forEach((item, index) => {\n          if (item.type === CSSRule.IMPORT_RULE) {\n            let importIndex = index + 1;\n            const url = item.href;\n            const deferred = fetchCSS(url).then(metadata => embedFonts(metadata, options)).then(cssText => parseCSS(cssText).forEach(rule => {\n              try {\n                sheet.insertRule(rule, rule.startsWith('@import') ? importIndex += 1 : sheet.cssRules.length);\n              } catch (error) {\n                console.error('Error inserting rule from remote css', {\n                  rule,\n                  error\n                });\n              }\n            })).catch(e => {\n              console.error('Error loading remote css', e.toString());\n            });\n            deferreds.push(deferred);\n          }\n        });\n      } catch (e) {\n        const inline = styleSheets.find(a => a.href == null) || document.styleSheets[0];\n        if (sheet.href != null) {\n          deferreds.push(fetchCSS(sheet.href).then(metadata => embedFonts(metadata, options)).then(cssText => parseCSS(cssText).forEach(rule => {\n            inline.insertRule(rule, inline.cssRules.length);\n          })).catch(err => {\n            console.error('Error loading remote stylesheet', err);\n          }));\n        }\n        console.error('Error inlining remote css file', e);\n      }\n    }\n  });\n  return Promise.all(deferreds).then(() => {\n    // Second loop parses rules\n    styleSheets.forEach(sheet => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray(sheet.cssRules || []).forEach(item => {\n            ret.push(item);\n          });\n        } catch (e) {\n          console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n        }\n      }\n    });\n    return ret;\n  });\n}\nfunction getWebFontRules(cssRules) {\n  return cssRules.filter(rule => rule.type === CSSRule.FONT_FACE_RULE).filter(rule => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nasync function parseWebFontRules(node, options) {\n  if (node.ownerDocument == null) {\n    throw new Error('Provided element is not within a Document');\n  }\n  const styleSheets = toArray(node.ownerDocument.styleSheets);\n  const cssRules = await getCSSRules(styleSheets, options);\n  return getWebFontRules(cssRules);\n}\nfunction normalizeFontFamily(font) {\n  return font.trim().replace(/[\"']/g, '');\n}\nfunction getUsedFonts(node) {\n  const fonts = new Set();\n  function traverse(node) {\n    const fontFamily = node.style.fontFamily || getComputedStyle(node).fontFamily;\n    fontFamily.split(',').forEach(font => {\n      fonts.add(normalizeFontFamily(font));\n    });\n    Array.from(node.children).forEach(child => {\n      if (child instanceof HTMLElement) {\n        traverse(child);\n      }\n    });\n  }\n  traverse(node);\n  return fonts;\n}\nexport async function getWebFontCSS(node, options) {\n  const rules = await parseWebFontRules(node, options);\n  const usedFonts = getUsedFonts(node);\n  const cssTexts = await Promise.all(rules.filter(rule => usedFonts.has(normalizeFontFamily(rule.style.fontFamily))).map(rule => {\n    const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n    return embedResources(rule.cssText, baseUrl, options);\n  }));\n  return cssTexts.join('\\n');\n}\nexport async function embedWebFonts(clonedNode, options) {\n  const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);\n  if (cssText) {\n    const styleNode = document.createElement('style');\n    const sytleContent = document.createTextNode(cssText);\n    styleNode.appendChild(sytleContent);\n    if (clonedNode.firstChild) {\n      clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n    } else {\n      clonedNode.appendChild(styleNode);\n    }\n  }\n}","map":{"version":3,"names":["toArray","fetchAsDataURL","shouldEmbed","embedResources","cssFetchCache","fetchCSS","url","cache","res","fetch","cssText","text","embedFonts","data","options","regexUrl","fontLocs","match","loadFonts","map","loc","replace","startsWith","URL","href","fetchRequestInit","_ref","result","Promise","all","then","parseCSS","source","commentsRegex","keyframesRegex","RegExp","matches","exec","push","importRegex","combinedCSSRegex","unifiedRegex","lastIndex","getCSSRules","styleSheets","ret","deferreds","forEach","sheet","cssRules","item","index","type","CSSRule","IMPORT_RULE","importIndex","deferred","metadata","rule","insertRule","length","error","console","catch","e","toString","inline","find","a","document","err","getWebFontRules","filter","FONT_FACE_RULE","style","getPropertyValue","parseWebFontRules","node","ownerDocument","Error","normalizeFontFamily","font","trim","getUsedFonts","fonts","Set","traverse","fontFamily","getComputedStyle","split","add","Array","from","children","child","HTMLElement","getWebFontCSS","rules","usedFonts","cssTexts","has","baseUrl","parentStyleSheet","join","embedWebFonts","clonedNode","fontEmbedCSS","skipFonts","styleNode","createElement","sytleContent","createTextNode","appendChild","firstChild","insertBefore"],"sources":["H:\\Asky\\node_modules\\html-to-image\\src\\embed-webfonts.ts"],"sourcesContent":["import type { Options } from './types'\nimport { toArray } from './util'\nimport { fetchAsDataURL } from './dataurl'\nimport { shouldEmbed, embedResources } from './embed-resources'\n\ninterface Metadata {\n  url: string\n  cssText: string\n}\n\nconst cssFetchCache: { [href: string]: Metadata } = {}\n\nasync function fetchCSS(url: string) {\n  let cache = cssFetchCache[url]\n  if (cache != null) {\n    return cache\n  }\n\n  const res = await fetch(url)\n  const cssText = await res.text()\n  cache = { url, cssText }\n\n  cssFetchCache[url] = cache\n\n  return cache\n}\n\nasync function embedFonts(data: Metadata, options: Options): Promise<string> {\n  let cssText = data.cssText\n  const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g\n  const fontLocs = cssText.match(/url\\([^)]+\\)/g) || []\n  const loadFonts = fontLocs.map(async (loc: string) => {\n    let url = loc.replace(regexUrl, '$1')\n    if (!url.startsWith('https://')) {\n      url = new URL(url, data.url).href\n    }\n\n    return fetchAsDataURL<[string, string]>(\n      url,\n      options.fetchRequestInit,\n      ({ result }) => {\n        cssText = cssText.replace(loc, `url(${result})`)\n        return [loc, result]\n      },\n    )\n  })\n\n  return Promise.all(loadFonts).then(() => cssText)\n}\n\nfunction parseCSS(source: string) {\n  if (source == null) {\n    return []\n  }\n\n  const result: string[] = []\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi\n  // strip out comments\n  let cssText = source.replace(commentsRegex, '')\n\n  // eslint-disable-next-line prefer-regex-literals\n  const keyframesRegex = new RegExp(\n    '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})',\n    'gi',\n  )\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matches = keyframesRegex.exec(cssText)\n    if (matches === null) {\n      break\n    }\n    result.push(matches[0])\n  }\n  cssText = cssText.replace(keyframesRegex, '')\n\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi\n  // to match css & media queries together\n  const combinedCSSRegex =\n    '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n    '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'\n  // unified regex\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi')\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let matches = importRegex.exec(cssText)\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText)\n      if (matches === null) {\n        break\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex\n    }\n    result.push(matches[0])\n  }\n\n  return result\n}\n\nasync function getCSSRules(\n  styleSheets: CSSStyleSheet[],\n  options: Options,\n): Promise<CSSStyleRule[]> {\n  const ret: CSSStyleRule[] = []\n  const deferreds: Promise<number | void>[] = []\n\n  // First loop inlines imports\n  styleSheets.forEach((sheet) => {\n    if ('cssRules' in sheet) {\n      try {\n        toArray<CSSRule>(sheet.cssRules || []).forEach((item, index) => {\n          if (item.type === CSSRule.IMPORT_RULE) {\n            let importIndex = index + 1\n            const url = (item as CSSImportRule).href\n            const deferred = fetchCSS(url)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  try {\n                    sheet.insertRule(\n                      rule,\n                      rule.startsWith('@import')\n                        ? (importIndex += 1)\n                        : sheet.cssRules.length,\n                    )\n                  } catch (error) {\n                    console.error('Error inserting rule from remote css', {\n                      rule,\n                      error,\n                    })\n                  }\n                }),\n              )\n              .catch((e) => {\n                console.error('Error loading remote css', e.toString())\n              })\n\n            deferreds.push(deferred)\n          }\n        })\n      } catch (e) {\n        const inline =\n          styleSheets.find((a) => a.href == null) || document.styleSheets[0]\n        if (sheet.href != null) {\n          deferreds.push(\n            fetchCSS(sheet.href)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  inline.insertRule(rule, inline.cssRules.length)\n                }),\n              )\n              .catch((err: unknown) => {\n                console.error('Error loading remote stylesheet', err)\n              }),\n          )\n        }\n        console.error('Error inlining remote css file', e)\n      }\n    }\n  })\n\n  return Promise.all(deferreds).then(() => {\n    // Second loop parses rules\n    styleSheets.forEach((sheet) => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray<CSSStyleRule>(sheet.cssRules || []).forEach((item) => {\n            ret.push(item)\n          })\n        } catch (e) {\n          console.error(`Error while reading CSS rules from ${sheet.href}`, e)\n        }\n      }\n    })\n\n    return ret\n  })\n}\n\nfunction getWebFontRules(cssRules: CSSStyleRule[]): CSSStyleRule[] {\n  return cssRules\n    .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n    .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')))\n}\n\nasync function parseWebFontRules<T extends HTMLElement>(\n  node: T,\n  options: Options,\n) {\n  if (node.ownerDocument == null) {\n    throw new Error('Provided element is not within a Document')\n  }\n\n  const styleSheets = toArray<CSSStyleSheet>(node.ownerDocument.styleSheets)\n  const cssRules = await getCSSRules(styleSheets, options)\n\n  return getWebFontRules(cssRules)\n}\n\nfunction normalizeFontFamily(font: string) {\n  return font.trim().replace(/[\"']/g, '')\n}\n\nfunction getUsedFonts(node: HTMLElement) {\n  const fonts = new Set<string>()\n  function traverse(node: HTMLElement) {\n    const fontFamily =\n      node.style.fontFamily || getComputedStyle(node).fontFamily\n    fontFamily.split(',').forEach((font) => {\n      fonts.add(normalizeFontFamily(font))\n    })\n\n    Array.from(node.children).forEach((child) => {\n      if (child instanceof HTMLElement) {\n        traverse(child)\n      }\n    })\n  }\n  traverse(node)\n  return fonts\n}\n\nexport async function getWebFontCSS<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<string> {\n  const rules = await parseWebFontRules(node, options)\n  const usedFonts = getUsedFonts(node)\n  const cssTexts = await Promise.all(\n    rules\n      .filter((rule) =>\n        usedFonts.has(normalizeFontFamily(rule.style.fontFamily)),\n      )\n      .map((rule) => {\n        const baseUrl = rule.parentStyleSheet\n          ? rule.parentStyleSheet.href\n          : null\n        return embedResources(rule.cssText, baseUrl, options)\n      }),\n  )\n\n  return cssTexts.join('\\n')\n}\n\nexport async function embedWebFonts<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const cssText =\n    options.fontEmbedCSS != null\n      ? options.fontEmbedCSS\n      : options.skipFonts\n      ? null\n      : await getWebFontCSS(clonedNode, options)\n\n  if (cssText) {\n    const styleNode = document.createElement('style')\n    const sytleContent = document.createTextNode(cssText)\n\n    styleNode.appendChild(sytleContent)\n\n    if (clonedNode.firstChild) {\n      clonedNode.insertBefore(styleNode, clonedNode.firstChild)\n    } else {\n      clonedNode.appendChild(styleNode)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}